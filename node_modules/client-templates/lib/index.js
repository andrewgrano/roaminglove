// Generated by CoffeeScript 1.7.0
(function() {
  var RootsUtil, UglifyJS, W, fs, minimatch, path, umd, _;

  path = require('path');

  fs = require('fs');

  _ = require('lodash');

  W = require('when');

  minimatch = require('minimatch');

  umd = require('umd');

  UglifyJS = require('uglify-js');

  RootsUtil = require('roots-util');

  module.exports = function(opts) {
    var ClientCompile;
    return ClientCompile = (function() {
      var after_category, after_hook, before_hook, write_hook;

      function ClientCompile(roots) {
        var _base, _ref;
        this.util = new RootsUtil(roots);
        this.opts = _.defaults(opts, {
          out: 'js/templates.js',
          name: 'templates',
          pattern: '**',
          concat: true,
          extract: true,
          compress: false,
          category: "precompiled"
        });
        _ref = this.opts, this.extract = _ref.extract, this.concat = _ref.concat, this.category = _ref.category, this.name = _ref.name, this.out = _ref.out, this.compress = _ref.compress;
        if (this.opts.base == null) {
          throw new Error('you must provide a base template path');
        }
        this.opts.base = path.normalize(this.opts.base);
        this.pattern = path.join(this.opts.base, this.opts.pattern);
        this.templates = {};
        this.write = this.concat ? !this.extract : true;
        if ((_base = roots.config).locals == null) {
          _base.locals = {};
        }
        roots.config.locals.client_templates = (function(_this) {
          return function(prefix) {
            if (prefix == null) {
              prefix = '';
            }
            return "<script src='" + prefix + _this.opts.out + "'></script>";
          };
        })(this);
      }

      ClientCompile.prototype.fs = function() {
        return {
          extract: this.extract,
          ordered: false,
          detect: (function(_this) {
            return function(f) {
              return minimatch(f.relative, _this.pattern);
            };
          })(this)
        };
      };

      ClientCompile.prototype.compile_hooks = function() {
        return {
          before_pass: before_hook.bind(this),
          after_file: after_hook.bind(this),
          write: write_hook.bind(this)
        };
      };

      ClientCompile.prototype.category_hooks = function() {
        return {
          after: after_category.bind(this)
        };
      };

      before_hook = function(ctx) {
        if (ctx.index === ctx.file.adapters.length) {
          ctx.file.original_content = ctx.file.content;
          return ctx.content = "";
        }
      };

      after_hook = function(ctx) {
        var adapter, _base, _name;
        adapter = _.find(_.clone(ctx.adapters).reverse(), function(a) {
          return a.name;
        });
        if ((_base = this.templates)[_name = adapter.name] == null) {
          _base[_name] = {
            adapter: adapter,
            all: []
          };
        }
        return adapter.compileClient(ctx.original_content, {
          filename: ctx.file.path
        }).then((function(_this) {
          return function(out) {
            var tpl_name;
            tpl_name = ctx.file.path.replace(ctx.roots.root, '');
            tpl_name = tpl_name.split(_this.opts.base)[1];
            tpl_name = tpl_name.split('.')[0];
            _this.templates[adapter.name].all.push({
              name: tpl_name,
              content: out.result
            });
            if (!_this.concat) {
              ctx.content = umd(tpl_name, out.result);
            }
            return _this.write;
          };
        })(this));
      };

      write_hook = function(ctx) {
        if (this.concat) {
          return false;
        }
        return {
          extension: 'js'
        };
      };

      after_category = function(ctx, category) {
        var name, output, tasks, tpl, _i, _len, _ref, _ref1;
        tasks = [];
        _ref = this.templates;
        for (name in _ref) {
          category = _ref[name];
          output = "";
          output += category.adapter.clientHelpers();
          if (this.concat) {
            output += "return {";
            _ref1 = category.all;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              tpl = _ref1[_i];
              if (tpl.name.indexOf('/') === 0) {
                tpl.name = tpl.name.substring(tpl.name.indexOf('/') + 1);
              }
              output += "\"" + tpl.name + "\": " + tpl.content + ",";
            }
            output = output.slice(0, -1);
            output += "};";
          }
          output = umd(this.name, output);
          if (this.compress) {
            output = UglifyJS.minify(output, {
              fromString: true
            }).code;
          }
          tasks.push(this.util.write(this.out, output));
        }
        return W.all(tasks);
      };

      return ClientCompile;

    })();
  };

}).call(this);
